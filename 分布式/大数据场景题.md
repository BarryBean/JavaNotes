# 1. 容量计算
解决海量数据问题前，先对数据的容量进行计算。
- 1 byte = 8 bit
- 1 KB = 2^10 byte = 1024 byte ≈ 10^3 byte
- 1 MB = 2^20 byte ≈ 10^6 byte
- 1 GB = 2^30 byte ≈ 10^9 byte
- 1 亿 = 10^8
- 1 个int整数占 4 byte，1 亿个整数占 4*108 byte ≈ 400 MB。


# 2. 海量数据判重
## 2.1 HashSet
答：将海量数据拆分到多台机器上，每台机器用HashSet存储，最好是用hash取模方式将一类数据都存放在同一机器上。

## 2.2 BitSet
答：构建一定大小的比特数组，让每个整数都映射到比特数组上，从而得知某个整数是否存在。
- 适用范围是海量整数数据，且范围不大。

## 2.3 布隆过滤器
答：铁则：**布隆过滤器说对其实可能不对，但说不对那就是不对。**

布隆过滤器是基于BitSet/BitMap的，每次插入数据都要经过k个哈希函数得到k个位置，把对应位置置为1。

查找数据时，也是相同流程，得到k个位置，若有一个不为1，则不存在，若都为1，可能存在也可能误判。

- 布隆过滤器只能插入不能删除。
- 优点在于利用很少的空间达到较高的精确率。
- 多个hash函数，增大随机性，减少碰撞概率。
- 扩大BitMap范围，使hash值均匀分布，减少碰撞。

## 2.4 前缀树
答：利用字符串的公共前缀减少查询时间，查询效率高。

前缀树特性是：
1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符；
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；
3. 每个节点的所有子节点包含的字符都不相同。

- 适用范围是海量字符串数据。


# 3. 海量整数找中位数
1亿个整数是400M，100亿个就是40GB，所以要分为内存足够和不足两种情况。

1. 内存足够，有40G。

将所有数加载进内存，用快排，每次划分后将索引和50亿比较，去左/右继续排序。
2. 内存不够，有4G。

用 2^32=4GB 的数组存储100亿个数出现的次数。统计结束后，从0开始类加桶内的数的索引，直到累加值为50亿对应元素就是中位数。
3. 内存不够，有512MB。

**第一次确定中位数的区间，第二次确定中位数的索引**。int整数的范围是[-2\^31,2\^31-1]划分100000组，每43000个数为一组，每次装载1亿个数，遍历放进对应区间，计数++。找到sum累加大于50亿的区间，记录区间的首尾。再按之前的方式遍历一遍100亿个整数，对区间设置一个桶用来统计元素个数。


# 4. 海量数据拆分
答：将数据拆分到多台机器上/将大文件拆分成小文件，让多台机器一起工作/对小文件求解。
## 4.1 拆分策略
1. 到达顺序：每次来的数据都放进当前Server，放满再放新增机器。
- 优点：充分利用系统资源；
- 缺点：需要查找表来存放数据-机器映射。
2. 哈希值：用数据的key进行hash取模 N(机器数量) 得到应放入的机器序号。
- 优点：不需要查找表；
- 缺点：hash分配不均匀；增加新机器全部重新算hash。
- 改进就是一致性hash(hash环) + 虚拟节点
3. 实际含义：例如，社交网站，将来自一个地区的用户尽可能存储在同一个机器上。
- 优点：避免多台机器查找，降低延迟；
- 缺点：使用查找表。





